A: Decode the secret Lua message.
    Secret Message #1: BE SURE TO DRINK YOUR OVALTINE

B1: Is the type checking in the C++ programming language primarily static or dynamic?
    In C++, I think the type checking is primarily static.

B2: What does this mean?
    This means that type checking for C++ is primarily done during compile time, or atleast before runtime. As opposed to dynamic, which is done during runtime

C: Consider the following grammar ... which of the following strings are in the language generated by this language?
    1, 3, 5.

D: Give an English description of the language generated by the following grammar
    This language contains strings that;
    1. An equal number of zero or more x's on the left hand side, and z's on the right hand side.
    2. an even number of y's in the middle (this include 0 y's).
    ex. '', 'xz', 'xyyz', 'xxxzzz', 'xxxxyyyyyyzzzz'

E: Consider the following regular expression (ab|c)*x*
    3, 4, 5.

F: Write a regular expression that matches words that contain at least one y, and no letters other than lower-case x, y, and z.
    y+(x|y|z)*

G: This problem deals with the following grammar
    1. Axy
    2. xyA
    3. S --> SS --> 1|2 (see 1 and 2 parse tree banches below)
        1. SS --> xyS
        2. SS --> Sxy
    4.  S --> A | B
        A --> xy
        B --> SB | S

H???: Consider the language containing those strings consisting of two or more 'a' characters followed by a single 'b' character. ex {aab, aaab, aaaab, aaaaab, ...}
    1. (a)(a+)(b)
    2???.  S -aa-> X
        X -a-> X
        X -b-> accepting state
    3.  S --> ABC
        A --> aa
        B --> aB | epsilon
        C --> b
    4. No, because there is only one parse tree.

I???: In class we described the syntax of regular expressions using informal methods. In this exercise, you will describe the syntax using a formal specification method.
    <reg-exp> ::= <char> | <char> <reg-exp> 
    <char-non-terminals> ::= <char>